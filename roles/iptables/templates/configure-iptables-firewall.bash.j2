#!/bin/bash

#
# Script to configure an iptables based firewall using template from Ansible playbook role.
#
# This file must be located in /etc/firewall.bash
#
# Common port reference:
#   22: SSH
#   25: SMTP
#   80: HTTP
#   123: NTP
#   443: HTTPS

#
# Bash sanity.
#
set -u

#
# Hosts and interfaces.
#
TARGET_SERVER='{{ ansible_hostname }}'
declare -a INTERNAL_INTERFACES=(
{% for internal_interface in internal_interfaces %}
	'{{ internal_interface }}'
{% endfor %}
)
declare -a EXTERNAL_INTERFACES=(
{% for external_interface in external_interfaces %}
	'{{ external_interface }}'
{% endfor %}
)

#
# Network addresses and ranges.
#
LOOPBACK='127.0.0.0/8'

declare -a ALLOW_ICMP_INBOUND=(
{% for ip in iptables_allow_icmp_inbound %}
	'{{ ip.addr }}'	# {{ ip.desc }}
{% endfor %}
)
declare -a ALLOW_SSH_INBOUND=(
{% for ip in iptables_allow_ssh_inbound %}
	'{{ ip.addr }}'	# {{ ip.desc }}
{% endfor %}
)
declare -a ALLOW_SSH_OUTBOUND=(
{% for ip in iptables_allow_ssh_outbound %}
	'{{ ip.addr }}'	# {{ ip.desc }}
{% endfor %}
)
declare -a ALLOW_EBI_MYSQL_OUTBOUND=(
{% for ip in iptables_allow_ebi_mysql_outbound %}
	'{{ ip.addr }}'	# {{ ip.desc }}
{% endfor %}
)
declare -a ALLOW_FTP_OUTBOUND=(
{% for ip in iptables_allow_ftp_outbound %}
	'{{ ip.addr }}'	# {{ ip.desc }}
{% endfor %}
)
declare -a ALLOW_ASPERA_OUTBOUND=(
{% for ip in iptables_allow_aspera_outbound %}
	'{{ ip.addr }}'	# {{ ip.desc }}
{% endfor %}
)
declare -a ALLOW_GLOBUS_OUTBOUND=(
{% for ip in iptables_allow_globus_outbound %}
	'{{ ip.addr }}'	# {{ ip.desc }}
{% endfor %}
)

#
##
### Main.
##
#

#
# Get (short) name of the server where this script is executed.
#  * Ignore the domain.
#  * Remove any -mgmt suffixes
#
SERVER_NAME="$(hostname -s)"
SERVER_NAME="$(echo ${SERVER_NAME} | sed 's/-mgmt//')"

#
# Check if we have a config valid for this server.
#
if [[ "${SERVER_NAME}" == "${TARGET_SERVER}" ]]; then
	echo "INFO: Hostname check passed. Will configure iptables firewall..."
else
	echo "ERROR: This config file is for \"${TARGET_SERVER}\", but this is \"${SERVER_NAME}\"."
	echo 'FATAL: Cannot configure firewall on this server.'
	exit 1
fi

#
##
### Kernel tweaks.
##
#


############ ToDo #####################################
# Kernel tweaks old and not yet migrated to new syntax.
#
echo '0' > /proc/sys/net/ipv4/ip_forward
#######################################################

#
# Prevent SYNC-floods.
#
echo '1' > /proc/sys/net/ipv4/tcp_syncookies # confusing name, but applies to IP version 6 as well.

#
# Limit response to ICMP packets.
#
echo '1' > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
echo '1' > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses

#
# Disable redirects and forwarding, which are only required on routers.
#
echo '0' > /proc/sys/net/ipv4/conf/all/accept_redirects
echo '0' > /proc/sys/net/ipv6/conf/all/accept_redirects
echo '0' > /proc/sys/net/ipv4/conf/all/forwarding
echo '0' > /proc/sys/net/ipv6/conf/all/forwarding

#
# Disable logging of spoofed packets, source routed packets, 
# and redirect packets to prevent flooding the logs.
#
echo '0' > /proc/sys/net/ipv4/conf/all/log_martians

#
# Disable source routed packets, which should only be required for debugging network issues.
#
echo '0' > /proc/sys/net/ipv4/conf/all/accept_source_route
echo '0' > /proc/sys/net/ipv6/conf/all/accept_source_route

#
# Enable IP spoofing protection.
#
echo '1' > /proc/sys/net/ipv4/conf/all/rp_filter

#
##
### IPv6: disable all and log.
##
#

#
# Flush and delete existing rules.
#
ip6tables -F
ip6tables -X

#
# Set the default policies to drop everything.
#
ip6tables -P INPUT DROP
ip6tables -P OUTPUT DROP
ip6tables -P FORWARD DROP

#
# We must accept IPv6 traffic on the loopback interface to prevent tests from failing
# during installation of verious software packages with network functionality.
#
ip6tables -A INPUT  -i lo -j ACCEPT
ip6tables -A OUTPUT -o lo -j ACCEPT

#
##
### IPv4.
##
#

#
# Initialize and flush everything to start with a clean slate.
#
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
iptables -t raw -F
iptables -t raw -X
iptables -t security -F
iptables -t security -X
iptables -Z

#
# Create custom chain for LOGDROP.
#
iptables -N LOGDROP
iptables -A LOGDROP -m limit --limit 15/minute -j LOG --log-level 7 --log-prefix 'Dropped by iptables firewall: '
iptables -A LOGDROP -j DROP

#
# Config default policies to drop.
#
# Log EVERYTHING (ONLY for Debug).
# iptables -A INPUT -j LOG
{% if iptables_log_dropped_packets %}
iptables -P INPUT   LOGDROP
{% else %}
iptables -P INPUT   DROP
{% endif %}
iptables -P OUTPUT  DROP
iptables -P FORWARD DROP

#
# Refuse loopback packets incoming from external interface.
#
for EXT_INTERFACE in "${EXTERNAL_INTERFACES[@]}"; do
	iptables -A INPUT -i "${EXT_INTERFACE}" -d "${LOOPBACK}" -j DROP
done

#
# Allow loopback.
#
iptables -A INPUT  -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

#
# Allow anything over internal interfaces.
#
for INT_INTERFACE in "${INTERNAL_INTERFACES[@]}"; do
	iptables -A INPUT  -i "${INT_INTERFACE}" -j ACCEPT
	iptables -A OUTPUT -o "${INT_INTERFACE}" -j ACCEPT
done

###############################################################################################################################################



# Forwarded ports.
{# Add a rule for each forwarded port #}
{% for forwarded_port in iptables_forwarded_tcp_ports %}
iptables -t nat -I PREROUTING -p tcp --dport {{ forwarded_port.src }} -j REDIRECT --to-port {{ forwarded_port.dest }}
iptables -t nat -I OUTPUT -p tcp -o lo --dport {{ forwarded_port.src }} -j REDIRECT --to-port {{ forwarded_port.dest }}
{% endfor %}
{% for forwarded_port in iptables_forwarded_udp_ports %}
iptables -t nat -I PREROUTING -p udp --dport {{ forwarded_port.src }} -j REDIRECT --to-port {{ forwarded_port.dest }}
iptables -t nat -I OUTPUT -p udp -o lo --dport {{ forwarded_port.src }} -j REDIRECT --to-port {{ forwarded_port.dest }}
{% endfor %}

#
# Allow established connections:
#
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT




############################################################################################################################3

#
# Allow all outbound ICMP.
# Allow limited inbound ICMP:
#    Type 0    Echo Reply   (a.k.a. pong) must be RELATED.
#    Type 8    Echo Request (a.k.a. ping)
#    Type 3    Destination Unreachable:
#              Unable to deliver the datagram to the specified network, host, protocal, or port.
#              Also sent if the datagram needs to be fragmented and the the Don't Fragment flag is on.
#              Required for Path-MTU Discovery and to prevent a PMTU "black hole".
#    Type 11   Time Exceeded:
#              The Time To Live (TTL) for the datagram has been exceeded.
#              Required for traceroute.
#
iptables -A OUTPUT -o ${INTERFACE_EXT} -p icmp -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT  -i ${INTERFACE_EXT} -p icmp -m state --state ESTABLISHED,RELATED     -j ACCEPT
for IP_ADDRESS in ${ALLOW_ICMP_INBOUND[@]}; do
  iptables -A INPUT  -i ${INTERFACE_EXT} -p icmp --icmp-type 3  -s ${IP_ADDRESS} -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
  iptables -A INPUT  -i ${INTERFACE_EXT} -p icmp --icmp-type 8  -s ${IP_ADDRESS} -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
  iptables -A INPUT  -i ${INTERFACE_EXT} -p icmp --icmp-type 11 -s ${IP_ADDRESS} -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
done

#
# Allow outbound NTP.
#
iptables -A OUTPUT -o ${INTERFACE_EXT} -p udp --dport 123 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT  -i ${INTERFACE_EXT} -p udp --sport 123 -m state --state ESTABLISHED     -j ACCEPT

#
# Allow outbound SMTP.
#
iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp -m multiport --dport 25,587 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT  -i ${INTERFACE_EXT} -p tcp -m multiport --sport 25,587 -m state --state ESTABLISHED     -j ACCEPT

#
# Allow outbound DNS.
#
iptables -A OUTPUT -o ${INTERFACE_EXT} -p udp --dport 53 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT  -i ${INTERFACE_EXT} -p udp --sport 53 -m state --state ESTABLISHED     -j ACCEPT
iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp --dport 53 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT  -i ${INTERFACE_EXT} -p tcp --sport 53 -m state --state ESTABLISHED     -j ACCEPT

#
# Allow outbound HTTP.
#
iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT  -i ${INTERFACE_EXT} -p tcp --sport 80 -m state --state ESTABLISHED     -j ACCEPT

#
# Allow outbound HTTPS.
#
iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT  -i ${INTERFACE_EXT} -p tcp --sport 443 -m state --state ESTABLISHED     -j ACCEPT

#
# Allow SSH inbound and outbound.
#
for IP_ADDRESS in ${ALLOW_SSH_INBOUND[@]}; do
  iptables -A INPUT  -i ${INTERFACE_EXT} -p tcp -s ${IP_ADDRESS} --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT
done
for IP_ADDRESS in ${ALLOW_SSH_OUTBOUND[@]}; do
  iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp -d ${IP_ADDRESS} --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT
done
iptables   -A OUTPUT -o ${INTERFACE_EXT} -p tcp                  --sport 22 -m state --state ESTABLISHED     -j ACCEPT
iptables   -A INPUT  -i ${INTERFACE_EXT} -p tcp                  --sport 22 -m state --state ESTABLISHED     -j ACCEPT

#
# Allow MySQL outbound.
#
# Required a.o. for conncections to the public Ensembl databases via the Ensembl Perl API
#
for IP_ADDRESS in ${ALLOW_EBI_MYSQL_OUTBOUND[@]}; do
  iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp -d ${IP_ADDRESS} -m multiport --dports 3306,5306,5316 -m state --state NEW,ESTABLISHED -j ACCEPT
done
iptables -A INPUT  -i ${INTERFACE_EXT} -p tcp                    -m multiport --sports 3306,5306,5316 -m state --state ESTABLISHED     -j ACCEPT

#
# Allow FTP outbound.
#
# We need a default and an additional connection tracking kernel module 
# in order to track FTP connections and know what is a RELATED connection.
# The extra module must be added to /etc/sysconfig/iptables-config
#    IPTABLES_MODULES="nf_conntrack_ftp"
#
/sbin/modprobe nf_conntrack     # Default module: should already be present, just checking here.
/sbin/modprobe nf_conntrack_ftp # Extra module: should be added to /etc/sysconfig/iptables-config, just checking here.
#
# Firstly, allow FTP control initiated by the client.
#
for IP_ADDRESS in ${ALLOW_FTP_OUTBOUND[@]}; do
  iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp -d ${IP_ADDRESS} --dport 21 -m state --state NEW,ESTABLISHED -j ACCEPT
done
iptables   -A INPUT  -i ${INTERFACE_EXT} -p tcp                  --sport 21 -m state --state ESTABLISHED     -j ACCEPT
#
# Secondly, allow FTP data connections.
#  * For Active Mode FTP the client must accept RELATED connections from the server on port 20 
#    to the client on a port number negotiated in the FTP control connection.
#  * For Passive Mode FTP the client starts a RELATED connection from a random own high port number 
#    to the server's fixed high port number negotiated in the FTP control connection.
#  * For both Active and Passive Mode FTP, the nf_conntrack_ftp kernel module is required at the FTP client 
#    to pick up the negotiated port number from the FTP control packet payloads.
#
iptables -A INPUT  -i ${INTERFACE_EXT} -p tcp --sport 20                  -m state --state ESTABLISHED,RELATED -j ACCEPT # Active Mode
iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp --dport 20                  -m state --state ESTABLISHED         -j ACCEPT # Active Mode
iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp --sport 1024: --dport 1024: -m state --state RELATED,ESTABLISHED -j ACCEPT # Passive Mode
iptables -A INPUT  -i ${INTERFACE_EXT} -p tcp --sport 1024: --dport 1024: -m state --state ESTABLISHED         -j ACCEPT # Passive Mode

#
# Allow Aspera outbound.
#
# Aspera requires (most common configs):
#  * SSH on either TCP port 22 or TCP 33001 for control and
#  * Data stream on at least UDP port 33001.
#    In case the server OS doesn't allow UDP port sharing a range of UDP ports is used
#    where the number of ports determines the max number of concurrent connections/clients.
#
for IP_ADDRESS in ${ALLOW_ASPERA_OUTBOUND[@]}; do
  iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp -d ${IP_ADDRESS} -m multiport --dports 22,33001    -m state --state NEW,ESTABLISHED -j ACCEPT
  iptables -A OUTPUT -o ${INTERFACE_EXT} -p udp -d ${IP_ADDRESS} -m multiport --dports 33001:33100 -m state --state NEW,ESTABLISHED -j ACCEPT
done
iptables   -A INPUT  -i ${INTERFACE_EXT} -p tcp                  -m multiport --sports 22,33001    -m state --state ESTABLISHED     -j ACCEPT
iptables   -A INPUT  -i ${INTERFACE_EXT} -p udp                  -m multiport --sports 33001:33100 -m state --state ESTABLISHED     -j ACCEPT

#
# Allow Globus outbound.
#
# Globus requires (most common configs) for "broker" service:
#  * TCP port  2223        outbound for control channel with the Globus Transfer service and for obtaining certificates during initial setup.
#                          Normally this will be the *.globus.org subnet.
#  * UDP port 19302        outbound for connecting to STUN server when setting up a session with another Globus Connect Personal endpoint.
#                          Normally this will be the stun.l.google.com Google STUN server.
# For each endpoint:
#  * TCP ports 50000-51000 outbound for data channel for transfers with Globus Connect Server endpoints.
#  * UDP ports 32768-65535 outbound for data channel for transfers with other Globus Connect Personal endpoints.

# ToDo: GLOBUS_ORG_NET and GOOGLE_STUN
iptables   -A OUTPUT -o ${INTERFACE_EXT} -p tcp -d ${GLOBUS_ORG_NET}          --dport 2223  -m state --state NEW,ESTABLISHED -j ACCEPT
iptables   -A OUTPUT -o ${INTERFACE_EXT} -p udp -d ${GOOGLE_STUN}             --dport 19302 -m state --state NEW,ESTABLISHED -j ACCEPT
for IP_ADDRESS in ${ALLOW_GLOBUS_OUTBOUND[@]}; do
  iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp -d ${IP_ADDRESS} -m multiport --dports 50000:51000 -m state --state NEW,ESTABLISHED -j ACCEPT
  iptables -A OUTPUT -o ${INTERFACE_EXT} -p udp -d ${IP_ADDRESS} -m multiport --dports 32678:65535 -m state --state NEW,ESTABLISHED -j ACCEPT
done

#
# (Re)start fail2ban, so it will (re)create a custom f2b-SSH iptables chain.
#
#service fail2ban restart

#
# List the rules:
#
echo '#'
echo '##'
echo '### iptables --list -n ###'
echo '##'
echo '#'
iptables --list -n
echo '#'
echo '##'
echo '### ip6tables --list -n ###'
echo '##'
echo '#'
ip6tables --list -n

#
# Save config for next boot.
#
service iptables save
service ip6tables save
