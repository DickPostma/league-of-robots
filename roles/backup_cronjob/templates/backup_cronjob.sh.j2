#!/bin/bash

# 2022-08-22 first draft
# 2022-08-23 add the options type, keepversions and destionation, shellcheck done

# {% raw %}
set -e
set -u 
set -o pipefail

if [ "${#}" -ne 5 ]; then
   echo "${0} \"name\" \"frequencyname\" \"keep\" \"/this/will/be/backed/up\" \"/destination/path\""
   echo "   name                [string] name of the backup (creates subdirectory main>name)"
   echo "   frequencyname       [string] frequency name of backup (creates subdirectory main>name>frequency)"
   echo "   keep                [number] how many backups to keep for this frequency"
   echo "   /source/...         [/path/...] to the folder that you would like to backup"
   echo "   /main/bckp/dst/...  [/path/...] to the *main* backup folder to keep all the backups"
   exit 1 
fi

backup_name="${1}"
backup_frequency="${2}"
keep_versions="${3}"
main_backup_destination="${5}"

log_file="${0}.log"
touch "${log_file}"
original_directory="$(pwd)"

# Check the if source directory exists and is readble
if ! test -r "${4}"; then
  echo "Error, (source) directory for backing up cannot be read/does not exist:"
  echo " -> ${4}"
  exit 255
else
  backup_source_formatted="$(cd "${4}" && pwd)"
fi

# Check if the main destination backup folder exist
if ! test -d "${main_backup_destination}/${backup_name}"; then
  echo "Error, one or more (destination) directories do not exist:"
  echo " -> ${main_backup_destination}/${backup_name}"
  exit 255
fi

destination_dir="${main_backup_destination}/${backup_name}/${backup_frequency}"
# Check the destination subdirectories and create them if missing
test -d "${destination_dir}" || mkdir "${destination_dir:-/tmp/eeerror}"

# Clean old logs (and keep only last 1024 lines)
log_short="$(tail -n 1024 "${log_file}")"
echo "${log_short}" > "${log_file}"

# Clean old backups
# list daily versions, sort by time, and keep only number of them, rest delete
# ! -path . suppreses '.' from output
purge_list="$(cd "${destination_dir}" && find . -maxdepth 1 ! -path . -type d -printf '%T@ %f\n' | sort -r | cut -d' ' -f2- | tail -n +"${keep_versions}")"
echo -e "Purging:\n${purge_list}" >> "${log_file}"
# ! -path . suppreses '.' from output
cd "${destination_dir}" && find . -maxdepth 1 ! -path . -type d -printf '%T@ %f\n' | sort -r | cut -d' ' -f2- | tail -n +"$((keep_versions + 1))" | xargs -I {} rm -rf -- ./{}

# FIND LAST DAILY BACKUP
# sort by modification time, newest first
# ! -path . suppreses '.' from output
latest_backup="$(cd "${destination_dir}" && find . -maxdepth 1 ! -path . -type d -printf '%T@ %f\n' | sort -r | cut -d' ' -f2- | head -n 1)" # take first
latest_linked=""
# else assemble the command
if [[ "x${latest_backup}" != "x" ]]; then
  latest_linked="--link-dest=${destination_dir}/${latest_backup}/"
fi

# Make the backup directory for the newest backup
current_time="$(date +%Y%m%d_%H%M%S)"
new_dir="${destination_dir}/${current_time}"
mkdir -p "${new_dir}"

# make daily backup and hard-link it against previous daily
rsync_command="rsync -aqH --protect-args --delete ${backup_source_formatted} ${new_dir}/. ${latest_linked}"
# Log command
echo "${rsync_command}" >> "${log_file}"
eval "${rsync_command}"
cd "${original_directory}" # return to home directory
# {% endraw %}
