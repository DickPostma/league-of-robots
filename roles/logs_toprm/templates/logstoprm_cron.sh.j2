#!/bin/bash

# First configure bash to correctly handle missing variables and errors
set -eEuo pipefail
_log_tag="logstoprm"
# We store all the extra information into the system logs, like civilized people
trap 'logger -t "${_log_tag}" "Command (${BASH_COMMAND}) has failed on line number (${LINENO})"' ERR

{% if logs_server_public_networks is defined and ( logs_server_public_networks|length > 0 ) %}

{% raw %}
#
# - this script is meant to run as cron on multiple machines
# - the only way the machines can communicate is via is via shared filesystem.
# - there the specific directory exists that the machines can create and write
# - the extra information about the machine that is running cron is stored in
#   additional files inside the lock directory
# - should work on samba/cifs (isilon), nfs and lustre - tested
# - the time is gathered from the cifs server's time, so it does not matter
#   how different the datetime settings are on the client side
# Other
# - for testing you can provide a string as a paramater, and that one will be
#   regarded in place of hostname (so that you can test and develop on local
#   machine)
#

#
## Variables
#

_lock_dirs="{% endraw %}{{ logs_toprm_destination }}{% raw%}/lock_dirs"      # full path
if ! test -d "${_lock_dirs}"; then mkdir -p ${_lock_dirs}; fi
_hostname="${1:-$(/bin/hostname)}"
_small_delay="30"       # [seconds] how long should cron wait (after lock directory is created) to start the process
_max_runtime=36000      # [seconds] how long can cron job run before being killed?
             # ^8h      # Should be less than time between to cron exections. If daily cron (86400s)
                        # then 80000 is appropriate. Note that the jobs can run longes, as _max_loop is
                        # the one that checks if job is too long, and kills the job if lasts too long
_max_loops="3"          # how many times should cronjob run and ignore (go to sleep without action), before
                        # starts cleaning stale processes?
_max_remote_time=21600  # [seconds] how long should current cron ignore the cron job from another host?
                # ^6h   # on top of job running already. Script removes lock folder and files after
                        #         now + ( _max_runtime * _max_loops ) + _max_remote_time
# placeholder variables to be later populated
_earl_name=''
# the main command we would like to run inside cron
_command="rsync -a --rsh=\"ssh -l {% endraw %}{{ logs_toprm_earl_user }}{% raw%}\" ${_earl_name}::logstoprm {% endraw %}{{ logs_toprm_destination }}{% raw%}/${_earl_name}"

_script_path_dir="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd -P )"

function get_servers_time(){
   _timedir=".testtimedir.${_hostname}"
   test -d ${_timedir} && rmdir ${_timedir} # clean old directory
   mkdir ${_timedir}
   _time_now=$(stat -c %Z ${_timedir})      # get server's time
   rmdir ${_timedir}
   logger -t "${_log_tag}" " - collected _time_now from server (seconds from epoch): ${_time_now}"
}

function check_time(){
   # first parameter is hostname (or is set to this hostname if not provided)
   # 1. check's if time file exist, and
   # 2. check time
   #                                            return   further action
   #     now > _time_delay_start                   0        can start
   #     if _start_time is unassigned              1        need to wait
   #     now < _time_delay_start                   1        need to wait
   #     now > _time_delay_start + _max_runtime    13       should kill process
   #     now >                                     14       should kill process
   #      _time_delay_start + ( _max_runtime * _max_loops ) + _max_remote_time
   #     file `time` is missing or wrong perms              log
   get_servers_time
   local _time_created
   _time_created=$(stat -c %Z ${1:-${_hostname}})     # does NOT include _small_delay, tail, as last one is the most important
   _time_delay_start="$((_time_created + _small_delay))"    # add delay to the time of when the lock folder has been created
   if test -z "${_time_delay_start}"; then logger -t "${_log_tag}" "Error _time_delay_start is empty" ; exit 255; fi  # the time is missing
   local _time_max_runtime=$((_time_delay_start + _max_runtime))
   local _time_max_remotetime=$(( _time_delay_start + ( _max_runtime * _max_loops ) + _max_remote_time))
   if [[ "${_time_now}" -gt "${_time_max_remotetime}" ]]; then
      logger -t "${_log_tag}" "Remote host runs for too long - returning 14!"
      return 14   # clean remote host lock directory and files
   elif [[ "${_time_now}" -gt "${_time_max_runtime}" ]]; then
      logger -t "${_log_tag}" "Should kill - returning 13!"
      return 13   # kill
   elif [[ "${_time_now}" -lt "${_time_delay_start}" ]]; then
      logger -t "${_log_tag}" "Should wait - returning 1!"
      return 1    # wait
   elif [[ "${_time_now}" -gt "${_time_delay_start}" ]]; then
      logger -t "${_log_tag}" "Should run - returning 0!"
      return 0    # run
   fi
}

function remove_locks(){
   # Cleaning up after run
   if test -d "${_hostname}"; then
      logger -t "${_log_tag}" " - cleaning up lock directories ... "
      rm -f "${_hostname}/"*
      rmdir ${_hostname}
   fi
}

function killing_pid(){                                                       # is either provided as a paramater or gets PIDs from file
   if test -n "${1:-}" ; then
      _pids=${1:-}
   elif test -e "${_hostname}/pid"; then
      _pids=$(sort -u < "${_hostname}/pid")
   else
      logger -t "${_log_tag}" "Error, no pid provided to kill and pid file is missing. Exit 255!"
      exit 255
   fi
   for _each_pid in ${_pids}; do
      if ps -u ${USER} -U ${USER} -o pid | grep ${_each_pid}; then
         logger -t "${_log_tag}" "Killing process ${_each_pid}"
         kill -9 ${_each_pid} && \
           logger -t "${_log_tag}" "Killing process ${_each_pid} - process killed!"
      fi
   done
}

function start_flow(){
   logger -t "${_log_tag}" "Starting main function"
   sync
   cd ${_script_path_dir}
   if ! test -w ${_lock_dirs}/; then
      logger -t "${_log_tag}" "Main locking directory is missing: ${_lock_dirs}"
   fi
   _all_host_count=$(ls -1 ${_lock_dirs} | wc -l)
   cd ${_lock_dirs}
   _my_hostname_count=$(find . -name "${_hostname}" | wc -l)
   _lock_dir="${_hostname}"
   if [[ "${_all_host_count}" -eq "0" ]]; then
      logger -t "${_log_tag}" " - no other host if running anything right now"
      logger -t "${_log_tag}" "   - making lock directory ${_lock_dir}"
      mkdir "${_lock_dir}" || { logger -t "${_log_tag}" "   - cannot create lock dir ${_lock_dir}" ; exit 255; }
      sync
      sleep ${_small_delay}                                                 # don't rush things
      start_flow
   else                                                                       # hosts are running things
      logger -t "${_log_tag}" " - there are lock directories"
      if [[ "${_my_hostname_count}" -gt "0" ]]; then
         logger -t "${_log_tag}" " - this hostname is supposed to be running the command right now"
         if [[ "${_my_hostname_count}" -eq "${_all_host_count}" ]]; then              # it's only my hostname
            logger -t "${_log_tag}" " - great, ONLY this hostname is supposed to be running the command right now"
            if check_time ; then
               logger -t "${_log_tag}" " - start delay is correct ... can proceed"
               _pidfile="${_hostname}/pid"
               # Is pid file inside and it contains pid?
               if test -e "${_pidfile}" && test -n "$(cat ${_pidfile})" ; then   # pidfile exists and is not empty
                  _running_pid="$(head -n1 < "${_pidfile}")"
                  _pidfile_nr_lines="$(wc -l < "${_pidfile}")"
                  if [[ "${_pidfile_nr_lines}" -ge "${_max_loops}" ]]; then   # we found this process running too many times, time to kill it
                     killing_pid
                     remove_locks
                  else                                                        # it exist and has a pid
                     logger -t "${_log_tag}" " - the process is already running > let's log this and exit"
                     echo "${_running_pid}" >> "${_pidfile}"                  # duplicating process ID inside pid file
                  fi
               else                                                           # we start the process
                  # Executing the main command
                  logger -t "${_log_tag}" "     - yes, let's run the main command"
                  { "${_command}" & }; _child="${!}"
                  echo "${_child}" >> "${_pidfile}"                           # storing process ID inside the pid file
                  # Next line ensures that process does not run longer than allowed
                  { ( sleep "${_max_runtime}"; \
                      logger -t "${_log_tag}" "Killing PID ${_child} due to running for too long!"; \
                      killing_pid "${_child}"; \
                  ) & } 1>/dev/null 2>&1
        # Next line ensures that process is killed if lock directory disappears
        { ( while test -d ${_lock_dir}; do sleep ${_small_delay}; done; \
            logger -t "${_log_tag}" "Killing PID ${_child} because the lock dir disappeared!"; \
                      killing_pid "${_child}"; \
                  ) & } 1>/dev/null 2>&1
        wait ${_child} 2>/dev/null || true                          # true ensures that the cleanup is done
                  remove_locks                                                # remove the lock files and directories
                  exit 0                                                      # job successfully finished
               fi
            else
               check_time || case ${?} in
                  1)
                     logger -t "${_log_tag}" "     - too early, let's wait ... "
                     sleep ${_small_delay} && start_flow         # go to start
                     ;;
                  13|14)
                     logger -t "${_log_tag}" "     - we should kill: this process is running for too long"
                     killing_pid
                     remove_locks
                     ;;
                  255)
                     logger -t "${_log_tag}" "Cannot get time of lock directory!"
                     exit 255
                     ;;
                  *)
                     logger -t "${_log_tag}" "Unknown error, should log"
                     ;;
            esac
            fi
         fi
      else
         logger -t "${_log_tag}" " - there are other hosts running this script"
         cd ${_lock_dirs}
         for _each_host in */; do                                             # loop through the hosts directories
            check_time "${_each_host}" || \
               if [[ "$?" -eq "14" ]]; then
                  logger -t "${_log_tag}" "This processes is running too long on the '${_each_host}' - removing the lock directory and files inside. Host will clean this processes on own side at next cron!"
                  rm -f "${_each_host}/"*               # remove all files, the selection of just 'time' and 'pid' could make issues
                                                        # if some other files would appear - like .nfsXXX .tmp or similar
                  rmdir "${_each_host}/"
               fi
         done
         logger -t "${_log_tag}" " - removing our host from the race and exit ... "
         test -d ${_hostname} && rmdir ${_hostname}
         exit 0
      fi
   fi
}

{% endraw %}
declare earl_servers=(
   {%- for logs_class in logs_server_public_networks -%}
   {%- for logs_server in logs_server_public_networks[logs_class] %}
     {{ logs_server.name }}
   {% endfor -%}
   {%- endfor -%}
)
{% raw %}
for _each_server in "${earl_servers[@]}"; do
   ( sleep $((RANDOM % _small_delay))  # small random delay, just in case if two systems would run the cron at the same time
   _earl_name="${_each_server}"
   start_flow
   ) 1>/dev/null 2>&1 &                # sent to background, so that if one node fails, others can finish normally
done
wait
{% endraw %}
{% endif %}
